{"ID":"1","language":"java","title":"calculate the GCD and LCM of two given numbers","content":"import java.util.Scanner;\npublic class GCD_LCM \n\n{\n    static int gcd(int x, int y)\n    {\n        int r=0, a, b;\n        a = (x &gt; y) ? x : y; // a is greater number\n        b = (x &lt; y) ? x : y; // b is smaller number\n\n        r = b;\n        while(a % b != 0)\n        {\n            r = a % b;\n            a =b;\n            b = r;\n        }\n        return r;\n    }\n\n    static int lcm(int x, int y)\n    {\n        int a;\n        a = (x &gt; y) ? x : y; // a is greater number\n        while(true)\n        {\n            if(a % x == 0 &amp;&amp; a % y == 0)\n                return a;\n            ++a;\n        }\n    }\n\n    public static void main(String args[])\n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter the two numbers: \");\n        int x = input.nextInt();\n        int y = input.nextInt();\n\n        System.out.println(\"The GCD of two numbers is: \" + gcd(x, y));\n        System.out.println(\"The LCM of two numbers is: \" + lcm(x, y));\n        input.close();\n    }\n}\n"} 
{"ID":"2","language":"java","title":"Find the Unique Factorization of a Given Number","content":"//Find the Unique Factorization of a Given Number/n/n/nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n public class Unique_Prime_Factors \n{\n    static Set primeFactors(long number) \n    {\n        long copy = number, i;\n   Set primeFactor = new HashSet&lt;&gt;();\n       for (i = 2; i &lt;= copy; i++) \n       {\n            if (copy % i == 0) \n           {\n               primeFactor.add(i);\n                 copy /= i;\n               i--;\n            }\n        }\n        return primeFactor;\n    }\n\n\n    public static void main(String args[]) \n     {\n         Scanner input = new Scanner(System.in);\n         long n;\n        System.out.println(\"Enter the number: \");\n         n = input.nextLong();\n         System.out.println(\"The Prime Factors of \" + n + \" is: \"\n                             + primeFactors(n));\n     }\n}"}
{"ID":"3","language":"java","title":"Euclid GCD Algorithm","content":"//Euclid GCD Algorithm\n\nfunction gcd(a, b)\n    if b = 0\n       return a\n    else\n       return gcd(b, a mod b)\n\n\nimport java.util.Scanner;\n \n\n/** Class EuclidGcd **/\npublic class EuclidGcd   \n {\n    /** Function to calculate gcd **/\n    public long gcd(long p, long q)\n    {\n        if (p % q == 0)\n            return q;\n        return gcd(q, p % q);\n    }\n    /** Main function **/\n    public static void main (String[] args)\n     {\n\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Euclid GCD Algorithm Test\n\");\n        /** Make an object of EuclidGcd class **/\n        EuclidGcd eg = new EuclidGcd();\n \n\n        /** Accept two integers **/\n        System.out.println(\"Enter two integer numbers\n\");\n        long n1 = scan.nextLong();\n        long n2 = scan.nextLong();\n        /** Call function gcd of class EuclidGcd **/\n        long gcd = eg.gcd(n1, n2);\n        System.out.println(\"\nGCD of \"+ n1 +\" and \"+ n2 +\" = \"+ gcd);\n    }\n}\n"}
{"ID":"4","language":"java","title":"Naor-Reingold Pseudo Random Function","content":"//Naor-Reingold Pseudo Random Function\n\nimport java.util.Random;\npublic class Naor_Reingold \n{\n    public static void main(String args[])\n    {\n        int p=7, l=3, g=2, n=4, x;\n        int []a = {1,2,2,1};\n        int []bin = new int[4];\n        Random random = new Random();\n        System.out.println(\"The Random numbers are: \");\n        for(int i=0; i&lt;10; i++)\n        {\n            x = random.nextInt(17);\n            for(int j=3; j&gt;=0; j--)\n            {\n                bin[j] = x%2;\n                x/=2;\n            }\n            int mul = 1;\n            for(int k=0; k&lt;4; k++)\n                mul *= Math.pow(a[k], bin[k]);\n            System.out.println(Math.pow(g, mul));\n        }\n    }\n}"}
{"ID":"5","language":"java","title":"Fermat Primality Test Algorithm","content":"//Fermat Primality Test Algorithm\n\nimport java.util.Scanner;\nimport java.util.Random;\n\n /** Class SolovayStrassen **/\npublic class SolovayStrassen\n{\n    /** Function to calculate jacobi (a/b) **/\n    public long Jacobi(long a, long b)\n    {\n        if (b &lt;= 0 || b % 2 == 0)\n            return 0;\n        long j = 1L;\n        if (a &lt; 0)\n        {\n            a = -a;\n            if (b % 4 == 3)\n                j = -j;\n        }\n        while (a != 0)\n      {\n            while (a % 2 == 0)\n            {\n                a /= 2;\n                if (b % 8 == 3 || b % 8 == 5)\n                    j = -j;\n            }\n \n            long temp = a;\n            a = b;\n            b = temp;\n \n            if (a % 4 == 3 &amp;&amp; b % 4 == 3)\n                j = -j\n            a %= b;\n        }\n        if (b == 1)\n            return j;\n        return 0;\n    }\n    /** Function to check if prime or not **/\n    public boolean isPrime(long n, int iteration)\n    {\n        /** base case **/\n        if (n == 0 || n == 1)\n            return false;\n        /** base case - 2 is prime **/\n        if (n == 2)\n            return true;\n        /** an even number other than 2 is composite **/\n        if (n % 2 == 0)\n            return false;\n \n        Random rand = new Random();\n        for (int i = 0; i &lt; iteration; i++)\n        {\n            long r = Math.abs(rand.nextLong());\n                       long a = r % (n - 1) + 1;\n            long jacobian = (n + Jacobi(a, n)) % n;\n            long mod = modPow(a, (n - 1)/2, n);\n            if(jacobian == 0 || mod != jacobian) \n                return false;\n        }\n        return true;       \n     }\n    /** Function to calculate (a ^ b) % c **/\n    public long modPow(long a, long b, long c)\n    {\n        long res = 1;\n        for (int i = 0; i &lt; b; i++)\n        {\n            res *= a;\n            res %= c; \n        }\n        return res % c;\n    }    \n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"SolovayStrassen Primality Algorithm Test\n\");\n        /** Make an object of SolovayStrassen class **/\n        SolovayStrassen ss = new SolovayStrassen();\n        /** Accept number **/\n        System.out.println(\"Enter number\n\");\n        long num = scan.nextLong();\n        /** Accept number of iterations **/\n        System.out.println(\"\nEnter number of iterations\");\n        intge k = scan.nextInt();\n        /** check if prime **/\n        boolean prime = ss.isPrime(num, k);\n        if (prime)\n            System.out.println(\"\n\"+ num +\" is prime\");\n        else\n            System.out.println(\"\n\"+ num +\" is composite\"); \n           }\n}\n"}
{"ID":"6","language":"java","title":"Regular Falsi Algorithm","content":"//Regular Falsi Algorithm\n\npublic class RegularFalsi\n{\n    /** function to find root for **/\n    public double f(double x)\n    {\n        /** make your own function here but accordingly change (s, t)\n **/\n \n         return Math.cos(x) - x * x * x;\n \n        // return x * x * x - 3 * x + 4;\n        // return Math.cos(x) - 3 * x + 1;\n        // return 2 * x - Math.log(x)/Math.log(10) - 7;\n        // return x * x - Math.log(x) - 12;\n    }\n    /** function to find root **/\n    public double findRoot(double s, double t, double e, int m)\n    {\n        double r = 0.0,fr;\n        int n, side = 0;\n \n        /** starting values at endpoints of interval **/\n        double fs = f(s);\n        double ft = f(t);\n \n        for (n = 0; n &lt; m; n++)\n        {\n \n            r = (fs * t - ft * s) / (fs - ft);\n            if (Math.abs(t - s) &lt; e * Math.abs(t + s)) \n                break;\n            fr = f(r);\n \n            if (fr * ft &gt; 0)\n            {\n                /** fr and ft have same sign, copy r to t **/\n                t = r; \n                ft = fr;\n                if (side == -1) \n                    fs /= 2;\n               side = -1;\n            }\n            else if (fs * fr &gt; 0)\n            {\n                /** fr and fs have same sign, copy r to s **/\n                s = r;  \n                fs = fr;\n                if (side == +1)\n                     ft /= 2;\n                side = +1;\n            }\n            else\n            {\n                /** fr * f_ very small (looks like zero) **/\n                break;\n            } \n        }\n        return r;\n    }\n    /** Main function **/\n    public static void main(String[] args)\n    {\n        System.out.println(\"Regular Falsi Test \");\n \n        RegularFalsi rf = new RegularFalsi();\n        /** lower limit **/\n        double s = 0;\n        /** upper limit **/\n        double t = 1;\n        /** half of upper bound for relative error **/\n        double e = 5E-15;\n        /** number of iterations **/\n        int iterations = 100;\n \n        System.out.println(\"\nRoot : \"+ rf.findRoot(s, t, e, iterations));\n    }\n}"}
{"ID":"7","language":"java","title":"Use rand and srand Functions","content":"//Use rand and srand Functions\n\nimport java.util.Random;\nimport java.util.UUID;\npublic class Rand_and_Srand \n{\n    public static void main(String args[])\n    {\n        System.out.println(\"The numbers using rand\");\n        for(int i=0; i&lt;5; i++)\n        {\n            Random rand = new Random();\n            System.out.println(Math.abs(rand.nextInt()));\n        }\n \n        System.out.println(\"The numbers using srand\");\n        for(int i=0; i&lt;5; i++)\n        {\n \n           System.out.println(Math.abs(UUID.randomUUID().getMostSignificantBits()\n));\n        }\n    }\n}\n"}
{"ID":"8","language":"java","title":"Solovay Strassen Primality Test Algorithm","content":"//Solovay Strassen Primality Test Algorithm\n\nimport java.util.Scanner;\nimport java.util.Random;\n \n/** Class SolovayStrassen **/\npublic class SolovayStrassen\n{\n    /** Function to calculate jacobi (a/b) **/\n    public long Jacobi(long a, long b)\n    {\n        if (b &lt;= 0 || b % 2 == 0)\n            return 0;\n        long j = 1L;\n        if (a &lt; 0)\n        {\n            a = -a;\n            if (b % 4 == 3)\n                j = -j;\n        }\n        while (a != 0)\n        {\n            while (a % 2 == 0)\n            {\n                a /= 2;\n                if (b % 8 == 3 || b % 8 == 5)\n                    j = -j;\n            }\n \n            long temp = a;\n            a = b;\n            b = temp;\n \n            if (a % 4 == 3 &amp;&amp; b % 4 == 3)\n                j = -j;\n            a %= b;\n        }\n        if (b == 1)\n            return j;\n        return 0;\n    }\n    /** Function to check if prime or not **/\n    public boolean isPrime(long n, int iteration)\n    {\n        /** base case **/\n        if (n == 0 || n == 1)\n            return false;\n        /** base case - 2 is prime **/\n        if (n == 2)\n            return true;\n        /** an even number other than 2 is composite **/\n        if (n % 2 == 0)\n            return false;\n \n        Random rand = new Random();\n        for (int i = 0; i &lt; iteration; i++)\n        {\n            long r = Math.abs(rand.nextLong()); \n                       long a = r % (n - 1) + 1;\n            long jacobian = (n + Jacobi(a, n)) % n;\n            long mod = modPow(a, (n - 1)/2, n);\n            if(jacobian == 0 || mod != jacobian) \n                return false;\n        }\n        return true;        \n    }\n    /** Function to calculate (a ^ b) % c **/\n    public long modPow(long a, long b, long c)\n    {\n        long res = 1;\n        for (int i = 0; i &lt; b; i++)\n        {\n            res *= a;\n            res %= c; \n        }\n        return res % c;\n    }    \n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"SolovayStrassen Primality Algorithm Test\n\");\n        /** Make an object of SolovayStrassen class **/\n        SolovayStrassen ss = new SolovayStrassen();\n        /** Accept number **/\n        System.out.println(\"Enter number\n\");\n        long num = scan.nextLong();\n        /** Accept number of iterations **/\n        System.out.println(\"\nEnter number of iterations\");\n        int k = scan.nextInt();\n        /** check if prime **/\n        boolean prime = ss.isPrime(num, k);\n        if (prime)\n            System.out.println(\"\n\"+ num +\" is prime\");\n        else\n            System.out.println(\"\n\"+ num +\" is composite\"); \n           }\n}"}
{"ID":"9","language":"java","title":"Gauss Seidel Method","content":"//Gauss Seidel Method\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n \npublic class Gauss_Seidel \n{\n    public static final int MAX_ITERATIONS = 100; \n     private double[][] M;\n    public Gauss_Seidel(double [][] matrix) { M = matrix; }\n \n    public void print()\n    {\n        int n = M.length;\n        for (int i = 0; i &lt; n; i++) \n        {\n            for (int j = 0; j &lt; n + 1; j++)\n                System.out.print(M[i][j] + \" \");\n            System.out.println();\n        }\n    }\n \n    public boolean transformToDominant(int r, boolean[] V, int[] R)\n    {        int n = M.length;\n        if (r == M.length) \n        {\n            double[][] T = new double[n][n+1];\n            for (int i = 0; i &lt; R.length; i++) \n            {\n                for (int j = 0; j &lt; n + 1; j++)\n                    T[i][j] = M[R[i]][j];\n            }\n \n            M = T;\n \n            return true;\n        }\n \n        for (int i = 0; i &lt; n; i++)\n         {\n            if (V[i]) continue;\n \n            double sum = 0;\n \n            for (int j = 0; j &lt; n; j++)\n                sum += Math.abs(M[i][j]);\n \n            if (2 * Math.abs(M[i][r]) &gt; sum) \n            { // diagonally dominant?\n                V[i] = true;\n                R[r] = i;\n \n                if (transformToDominant(r + 1, V, R))\n                    return true;\n \n                V[i] = false;\n            }\n        }\n \n        return false;\n    }\n \n    public boolean makeDominant()\n    {\n        boolean[] visited = new boolean[M.length];\n        int[] rows = new int[M.length];\n \n        Arrays.fill(visited, false);\n \n        return transformToDominant(0, visited, rows);\n    }\n \n    public void solve()\n    {\n        int iterations = 0;\n        int n = M.length;        double epsilon = 1e-15;\n        double[] X = new double[n]; // Approximations\n        double[] P = new double[n]; // Prev\n        Arrays.fill(X, 0);\n \n        while (true) \n        {\n            for (int i = 0; i &lt; n; i++) \n            {\n                double sum = M[i][n]; // b_n\n \n                for (int j = 0; j &lt; n; j++)\n                    if (j != i)\n                        sum -= M[i][j] * X[j];\n \n        // Update x_i to use in the next row calculation\n                X[i] = 1/M[i][i] * sum;\n            }\n \n            System.out.print(\"X_\" + iterations + \" = {\");\n            for (int i = 0; i &lt; n; i++)\n                System.out.print(X[i] + \" \");\n            System.out.println(\"}\");\n \n            iterations++;\n            if (iterations == 1) \n                continue;\n \n            boolean stop = true;\n            for (int i = 0; i &lt; n &amp;&amp; stop; i++)\n                if (Math.abs(X[i] - P[i]) &gt; epsilon)\n                    stop = false;\n \n            if (stop || iterations == MAX_ITERATIONS) break;\n            P = (double[])X.clone();\n        }\n    }\n \n    public static void main(String[] args) throws IOException\n    {\n        int n;\n        double[][] M;\n \nBufferedReader reader = new BufferedReader(new\n InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(System.out, true);\n \n        System.out.println(\"Enter the number of variables in the\n equation:\");\n        n = Integer.parseInt(reader.readLine());\n        M = new double[n][n+1];\n        System.out.println(\"Enter the augmented matrix:\");\n \n        for (int i = 0; i &lt; n; i++)\n         {\n            StringTokenizer strtk = new StringTokenizer(reader.readLine());\n \n            while (strtk.hasMoreTokens())\n                for (int j = 0; j &lt; n + 1 &amp;&amp; strtk.hasMoreTokens(); j++)\n                    M[i][j] = Integer.parseInt(strtk.nextToken());\n        }\n \n \n        Gauss_Seidel gausSeidel = new Gauss_Seidel(M);\n \n        if (!gausSeidel.makeDominant())\n         {\n            writer.println(\"The system isn't diagonally dominant: \" +\n                     \"The method cannot guarantee convergence.\");\n        }\n \n        writer.println();\n        gausSeidel.print();\n        gausSeidel.solve();\n    }\n}\n"}
{"ID":"10","language":"java","title":"Strassen Algorithm","content":"//Strassen Algorithm\n\nimport java.util.Scanner;\n/** Class Strassen **/\npublic class Strassen\n{\n    /** Function to multiply matrices **/\n    public int[][] multiply(int[][] A, int[][] B)\n    {        \n        int n = A.length;\n        int[][] R = new int[n][n];\n        /** base case **/\n        if (n == 1)\n            R[0][0] = A[0][0] * B[0][0];\n        else\n        {\n            int[][] A11 = new int[n/2][n/2];\n            int[][] A12 = new int[n/2][n/2];\n            int[][] A21 = new int[n/2][n/2];\n            int[][] A22 = new int[n/2][n/2];\n            int[][] B11 = new int[n/2][n/2];\n            int[][] B12 = new int[n/2][n/2];\n            int[][] B21 = new int[n/2][n/2];\n            int[][] B22 = new int[n/2][n/2];\n \n            /** Dividing matrix A into 4 halves **/\n            split(A, A11, 0 , 0);\n            split(A, A12, 0 , n/2);\n            split(A, A21, n/2, 0);\n            split(A, A22, n/2, n/2);\n            /** Dividing matrix B into 4 halves **/\n            split(B, B11, 0 , 0);\n            split(B, B12, 0 , n/2);\n            split(B, B21, n/2, 0);\n            split(B, B22, n/2, n/2);\n \n            /** \n              M1 = (A11 + A22)(B11 + B22)\n              M2 = (A21 + A22) B11\n              M3 = A11 (B12 - B22)\n              M4 = A22 (B21 - B11)\n              M5 = (A11 + A12) B22\n              M6 = (A21 - A11) (B11 + B12)\n              M7 = (A12 - A22) (B21 + B22)\n            **/\n \n            int [][] M1 = multiply(add(A11, A22), add(B11, B22));\n            int [][] M2 = multiply(add(A21, A22), B11);\n            int [][] M3 = multiply(A11, sub(B12, B22));\n            int [][] M4 = multiply(A22, sub(B21, B11));\n            int [][] M5 = multiply(add(A11, A12), B22);\n            int [][] M6 = multiply(sub(A21, A11), add(B11, B12));\n            int [][] M7 = multiply(sub(A12, A22), add(B21, B22));\n \n            /**\n              C11 = M1 + M4 - M5 + M7\n              C12 = M3 + M5\n              C21 = M2 + M4\n              C22 = M1 - M2 + M3 + M6\n            **/\n            int [][] C11 = add(sub(add(M1, M4), M5), M7);\n            int [][] C12 = add(M3, M5);\n            int [][] C21 = add(M2, M4);\n            int [][] C22 = add(sub(add(M1, M3), M2), M6);\n \n            /** join 4 halves into one result matrix **/\n            join(C11, R, 0 , 0);\n            join(C12, R, 0 , n/2);\n            join(C21, R, n/2, 0);\n            join(C22, R, n/2, n/2);\n        }\n        /** return result **/ \n           return R;\n    }\n    /** Funtion to sub two matrices **/\n    public int[][] sub(int[][] A, int[][] B)\n    {\n        int n = A.length;\n        int[][] C = new int[n][n];\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                C[i][j] = A[i][j] - B[i][j];\n        return C;\n    }\n    /** Funtion to add two matrices **/\n    public int[][] add(int[][] A, int[][] B)\n    {\n        int n = A.length;\n        int[][] C = new int[n][n];\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                C[i][j] = A[i][j] + B[i][j];\n        return C;\n    }\n    /** Funtion to split parent matrix into child matrices **/\n    public void split(int[][] P, int[][] C, int iB, int jB) \n    {\n        for(int i1 = 0, i2 = iB; i1 &lt; C.length; i1++, i2++)\n            for(int j1 = 0, j2 = jB; j1 &lt; C.length; j1++, j2++)\n                C[i1][j1] = P[i2][j2];\n    }\n    /** Funtion to join child matrices intp parent matrix **/\n    public void join(int[][] C, int[][] P, int iB, int jB) \n    {\n        for(int i1 = 0, i2 = iB; i1 &lt; C.length; i1++, i2++)\n            for(int j1 = 0, j2 = jB; j1 &lt; C.length; j1++, j2++)\n                P[i2][j2] = C[i1][j1];\n    }    \n    /** Main function **/\n    public static void main (String[] args)\n     {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Strassen Multiplication Algorithm Test\n\");\n        /** Make an object of Strassen class **/\n        Strassen s = new Strassen();\n \n        System.out.println(\"Enter order n :\");\n        int N = scan.nextInt();\n        /** Accept two 2d matrices **/\n        System.out.println(\"Enter N order matrix 1\n\");\n        int[][] A = new int[N][N];\n        for (int i = 0; i &lt; N; i++)\n            for (int j = 0; j &lt; N; j++)\n                A[i][j] = scan.nextInt();\n \n        System.out.println(\"Enter N order matrix 2\n\");\n        int[][] B = new int[N][N];\n        for (int i = 0; i &lt; N; i++)\n            for (int j = 0; j &lt; N; j++)\n                B[i][j] = scan.nextInt();\n \n        int[][] C = s.multiply(A, B);\n \n        System.out.println(\"\nProduct of matrices A and  B : \");\n        for (int i = 0; i &lt; N; i++)\n        {\n            for (int j = 0; j &lt; N; j++)\n                System.out.print(C[i][j] +\" \");\n            System.out.println();\n        }\n \n    }\n}\n"}
{"ID":"11","language":"java","title":"Matrix Multiplication","content":"//Matrix Multiplication\n\npackage com.sanfoundry.numerical;\nimport java.util.Scanner;\n \npublic class MatixMultiplication\n{\n    public static void main(String args[])\n    {\n        int n;\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter the base of squared matrices\");\n        n = input.nextInt();\n        int[][] a = new int[n][n];\n        int[][] b = new int[n][n];\n        int[][] c = new int[n][n];\n        System.out.println(\"Enter the elements of 1st martix row wise \n\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                a[i][j] = input.nextInt();\n            }\n        }\n  System.out.println(\"Enter the elements of 2nd martix row wise \n\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                b[i][j] = input.nextInt();\n            }\n        }\n        System.out.println(\"Multiplying the matrices...\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                for (int k = 0; k &lt; n; k++)\n                {\n                    c[i][j] = c[i][j] + a[i][k] * b[k][j];\n                }\n            }\n        }\n        System.out.println(\"The product is:\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                System.out.print(c[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        input.close();\n    }\n}"}
{"ID":"31","language":"java","title":"Horner Algorithm","content":"//Horner Algorithm import java.util.Scanner;\n\n    public class Horner\n\n    {\n    private int sum;\n     /** constructor **/\n    public Horner(int[] cof, int x)\n    {\n        sum = 0;\n        calcSum(cof, x, cof.length - 1);\n        display();\n    }\n       /** Calculate sum *\n*/\n    private void calcSum(int[] cof, int x, int N)\n    {\n        sum = cof[N] * x;\n        for (int i = N - 1; i &gt;= 1; i--)\n        sum = (sum + cof[i]) * x;\n        sum += cof[0];\n    }\n    public void display()\n    {\n        System.out.println(\"Evaluated sum = \"+ sum);\n    }\n      /** main method **/\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Horner Algorithm Test\n\");\n        System.out.println(\"Enter highest power\");\n           int n = scan.nextInt();\n           int[] arr = new int[n + 1];\n      System.out.println(\"\nEnter \"+ (n + 1) +\" coefficients in$ increasing order\");\n       for (int i = 0; i &lt;= n; i++)\n           arr[i] = scan.nextInt();\n      System.out.println(\"\nEnter x\");\n      int x = scan.nextInt();\n          Horner h = new Horner(arr, x);\n       }\n     }\n"}