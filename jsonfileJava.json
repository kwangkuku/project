{"ID":"1","language":"java","title":"calculate the GCD and LCM of two given numbers","content":"import java.util.Scanner;\npublic class GCD_LCM \n\n{\n    static int gcd(int x, int y)\n    {\n        int r=0, a, b;\n        a = (x &gt; y) ? x : y; // a is greater number\n        b = (x &lt; y) ? x : y; // b is smaller number\n\n        r = b;\n        while(a % b != 0)\n        {\n            r = a % b;\n            a =b;\n            b = r;\n        }\n        return r;\n    }\n\n    static int lcm(int x, int y)\n    {\n        int a;\n        a = (x &gt; y) ? x : y; // a is greater number\n        while(true)\n        {\n            if(a % x == 0 &amp;&amp; a % y == 0)\n                return a;\n            ++a;\n        }\n    }\n\n    public static void main(String args[])\n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter the two numbers: \");\n        int x = input.nextInt();\n        int y = input.nextInt();\n\n        System.out.println(\"The GCD of two numbers is: \" + gcd(x, y));\n        System.out.println(\"The LCM of two numbers is: \" + lcm(x, y));\n        input.close();\n    }\n}\n"} 
{"ID":"2","language":"java","title":"Find the Unique Factorization of a Given Number","content":"//Find the Unique Factorization of a Given Number/n/n/nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n public class Unique_Prime_Factors \n{\n    static Set primeFactors(long number) \n    {\n        long copy = number, i;\n   Set primeFactor = new HashSet&lt;&gt;();\n       for (i = 2; i &lt;= copy; i++) \n       {\n            if (copy % i == 0) \n           {\n               primeFactor.add(i);\n                 copy /= i;\n               i--;\n            }\n        }\n        return primeFactor;\n    }\n\n\n    public static void main(String args[]) \n     {\n         Scanner input = new Scanner(System.in);\n         long n;\n        System.out.println(\"Enter the number: \");\n         n = input.nextLong();\n         System.out.println(\"The Prime Factors of \" + n + \" is: \"\n                             + primeFactors(n));\n     }\n}"}
{"ID":"3","language":"java","title":"Euclid GCD Algorithm","content":"//Euclid GCD Algorithm\n\nfunction gcd(a, b)\n    if b = 0\n       return a\n    else\n       return gcd(b, a mod b)\n\n\nimport java.util.Scanner;\n \n\n/** Class EuclidGcd **/\npublic class EuclidGcd   \n {\n    /** Function to calculate gcd **/\n    public long gcd(long p, long q)\n    {\n        if (p % q == 0)\n            return q;\n        return gcd(q, p % q);\n    }\n    /** Main function **/\n    public static void main (String[] args)\n     {\n\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Euclid GCD Algorithm Test\n\");\n        /** Make an object of EuclidGcd class **/\n        EuclidGcd eg = new EuclidGcd();\n \n\n        /** Accept two integers **/\n        System.out.println(\"Enter two integer numbers\n\");\n        long n1 = scan.nextLong();\n        long n2 = scan.nextLong();\n        /** Call function gcd of class EuclidGcd **/\n        long gcd = eg.gcd(n1, n2);\n        System.out.println(\"\nGCD of \"+ n1 +\" and \"+ n2 +\" = \"+ gcd);\n    }\n}\n"}
{"ID":"4","language":"java","title":"Naor-Reingold Pseudo Random Function","content":"//Naor-Reingold Pseudo Random Function\n\nimport java.util.Random;\npublic class Naor_Reingold \n{\n    public static void main(String args[])\n    {\n        int p=7, l=3, g=2, n=4, x;\n        int []a = {1,2,2,1};\n        int []bin = new int[4];\n        Random random = new Random();\n        System.out.println(\"The Random numbers are: \");\n        for(int i=0; i&lt;10; i++)\n        {\n            x = random.nextInt(17);\n            for(int j=3; j&gt;=0; j--)\n            {\n                bin[j] = x%2;\n                x/=2;\n            }\n            int mul = 1;\n            for(int k=0; k&lt;4; k++)\n                mul *= Math.pow(a[k], bin[k]);\n            System.out.println(Math.pow(g, mul));\n        }\n    }\n}"}
{"ID":"5","language":"java","title":"Fermat Primality Test Algorithm","content":"//Fermat Primality Test Algorithm\n\nimport java.util.Scanner;\nimport java.util.Random;\n\n /** Class SolovayStrassen **/\npublic class SolovayStrassen\n{\n    /** Function to calculate jacobi (a/b) **/\n    public long Jacobi(long a, long b)\n    {\n        if (b &lt;= 0 || b % 2 == 0)\n            return 0;\n        long j = 1L;\n        if (a &lt; 0)\n        {\n            a = -a;\n            if (b % 4 == 3)\n                j = -j;\n        }\n        while (a != 0)\n      {\n            while (a % 2 == 0)\n            {\n                a /= 2;\n                if (b % 8 == 3 || b % 8 == 5)\n                    j = -j;\n            }\n \n            long temp = a;\n            a = b;\n            b = temp;\n \n            if (a % 4 == 3 &amp;&amp; b % 4 == 3)\n                j = -j\n            a %= b;\n        }\n        if (b == 1)\n            return j;\n        return 0;\n    }\n    /** Function to check if prime or not **/\n    public boolean isPrime(long n, int iteration)\n    {\n        /** base case **/\n        if (n == 0 || n == 1)\n            return false;\n        /** base case - 2 is prime **/\n        if (n == 2)\n            return true;\n        /** an even number other than 2 is composite **/\n        if (n % 2 == 0)\n            return false;\n \n        Random rand = new Random();\n        for (int i = 0; i &lt; iteration; i++)\n        {\n            long r = Math.abs(rand.nextLong());\n                       long a = r % (n - 1) + 1;\n            long jacobian = (n + Jacobi(a, n)) % n;\n            long mod = modPow(a, (n - 1)/2, n);\n            if(jacobian == 0 || mod != jacobian) \n                return false;\n        }\n        return true;       \n     }\n    /** Function to calculate (a ^ b) % c **/\n    public long modPow(long a, long b, long c)\n    {\n        long res = 1;\n        for (int i = 0; i &lt; b; i++)\n        {\n            res *= a;\n            res %= c; \n        }\n        return res % c;\n    }    \n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"SolovayStrassen Primality Algorithm Test\n\");\n        /** Make an object of SolovayStrassen class **/\n        SolovayStrassen ss = new SolovayStrassen();\n        /** Accept number **/\n        System.out.println(\"Enter number\n\");\n        long num = scan.nextLong();\n        /** Accept number of iterations **/\n        System.out.println(\"\nEnter number of iterations\");\n        intge k = scan.nextInt();\n        /** check if prime **/\n        boolean prime = ss.isPrime(num, k);\n        if (prime)\n            System.out.println(\"\n\"+ num +\" is prime\");\n        else\n            System.out.println(\"\n\"+ num +\" is composite\"); \n           }\n}\n"}
{"ID":"6","language":"java","title":"Regular Falsi Algorithm","content":"//Regular Falsi Algorithm\n\npublic class RegularFalsi\n{\n    /** function to find root for **/\n    public double f(double x)\n    {\n        /** make your own function here but accordingly change (s, t)\n **/\n \n         return Math.cos(x) - x * x * x;\n \n        // return x * x * x - 3 * x + 4;\n        // return Math.cos(x) - 3 * x + 1;\n        // return 2 * x - Math.log(x)/Math.log(10) - 7;\n        // return x * x - Math.log(x) - 12;\n    }\n    /** function to find root **/\n    public double findRoot(double s, double t, double e, int m)\n    {\n        double r = 0.0,fr;\n        int n, side = 0;\n \n        /** starting values at endpoints of interval **/\n        double fs = f(s);\n        double ft = f(t);\n \n        for (n = 0; n &lt; m; n++)\n        {\n \n            r = (fs * t - ft * s) / (fs - ft);\n            if (Math.abs(t - s) &lt; e * Math.abs(t + s)) \n                break;\n            fr = f(r);\n \n            if (fr * ft &gt; 0)\n            {\n                /** fr and ft have same sign, copy r to t **/\n                t = r; \n                ft = fr;\n                if (side == -1) \n                    fs /= 2;\n               side = -1;\n            }\n            else if (fs * fr &gt; 0)\n            {\n                /** fr and fs have same sign, copy r to s **/\n                s = r;  \n                fs = fr;\n                if (side == +1)\n                     ft /= 2;\n                side = +1;\n            }\n            else\n            {\n                /** fr * f_ very small (looks like zero) **/\n                break;\n            } \n        }\n        return r;\n    }\n    /** Main function **/\n    public static void main(String[] args)\n    {\n        System.out.println(\"Regular Falsi Test \");\n \n        RegularFalsi rf = new RegularFalsi();\n        /** lower limit **/\n        double s = 0;\n        /** upper limit **/\n        double t = 1;\n        /** half of upper bound for relative error **/\n        double e = 5E-15;\n        /** number of iterations **/\n        int iterations = 100;\n \n        System.out.println(\"\nRoot : \"+ rf.findRoot(s, t, e, iterations));\n    }\n}"}
{"ID":"7","language":"java","title":"Use rand and srand Functions","content":"//Use rand and srand Functions\n\nimport java.util.Random;\nimport java.util.UUID;\npublic class Rand_and_Srand \n{\n    public static void main(String args[])\n    {\n        System.out.println(\"The numbers using rand\");\n        for(int i=0; i&lt;5; i++)\n        {\n            Random rand = new Random();\n            System.out.println(Math.abs(rand.nextInt()));\n        }\n \n        System.out.println(\"The numbers using srand\");\n        for(int i=0; i&lt;5; i++)\n        {\n \n           System.out.println(Math.abs(UUID.randomUUID().getMostSignificantBits()\n));\n        }\n    }\n}\n"}
{"ID":"8","language":"java","title":"Solovay Strassen Primality Test Algorithm","content":"//Solovay Strassen Primality Test Algorithm\n\nimport java.util.Scanner;\nimport java.util.Random;\n \n/** Class SolovayStrassen **/\npublic class SolovayStrassen\n{\n    /** Function to calculate jacobi (a/b) **/\n    public long Jacobi(long a, long b)\n    {\n        if (b &lt;= 0 || b % 2 == 0)\n            return 0;\n        long j = 1L;\n        if (a &lt; 0)\n        {\n            a = -a;\n            if (b % 4 == 3)\n                j = -j;\n        }\n        while (a != 0)\n        {\n            while (a % 2 == 0)\n            {\n                a /= 2;\n                if (b % 8 == 3 || b % 8 == 5)\n                    j = -j;\n            }\n \n            long temp = a;\n            a = b;\n            b = temp;\n \n            if (a % 4 == 3 &amp;&amp; b % 4 == 3)\n                j = -j;\n            a %= b;\n        }\n        if (b == 1)\n            return j;\n        return 0;\n    }\n    /** Function to check if prime or not **/\n    public boolean isPrime(long n, int iteration)\n    {\n        /** base case **/\n        if (n == 0 || n == 1)\n            return false;\n        /** base case - 2 is prime **/\n        if (n == 2)\n            return true;\n        /** an even number other than 2 is composite **/\n        if (n % 2 == 0)\n            return false;\n \n        Random rand = new Random();\n        for (int i = 0; i &lt; iteration; i++)\n        {\n            long r = Math.abs(rand.nextLong()); \n                       long a = r % (n - 1) + 1;\n            long jacobian = (n + Jacobi(a, n)) % n;\n            long mod = modPow(a, (n - 1)/2, n);\n            if(jacobian == 0 || mod != jacobian) \n                return false;\n        }\n        return true;        \n    }\n    /** Function to calculate (a ^ b) % c **/\n    public long modPow(long a, long b, long c)\n    {\n        long res = 1;\n        for (int i = 0; i &lt; b; i++)\n        {\n            res *= a;\n            res %= c; \n        }\n        return res % c;\n    }    \n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"SolovayStrassen Primality Algorithm Test\n\");\n        /** Make an object of SolovayStrassen class **/\n        SolovayStrassen ss = new SolovayStrassen();\n        /** Accept number **/\n        System.out.println(\"Enter number\n\");\n        long num = scan.nextLong();\n        /** Accept number of iterations **/\n        System.out.println(\"\nEnter number of iterations\");\n        int k = scan.nextInt();\n        /** check if prime **/\n        boolean prime = ss.isPrime(num, k);\n        if (prime)\n            System.out.println(\"\n\"+ num +\" is prime\");\n        else\n            System.out.println(\"\n\"+ num +\" is composite\"); \n           }\n}"}
{"ID":"9","language":"java","title":"Gauss Seidel Method","content":"//Gauss Seidel Method\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n \npublic class Gauss_Seidel \n{\n    public static final int MAX_ITERATIONS = 100; \n     private double[][] M;\n    public Gauss_Seidel(double [][] matrix) { M = matrix; }\n \n    public void print()\n    {\n        int n = M.length;\n        for (int i = 0; i &lt; n; i++) \n        {\n            for (int j = 0; j &lt; n + 1; j++)\n                System.out.print(M[i][j] + \" \");\n            System.out.println();\n        }\n    }\n \n    public boolean transformToDominant(int r, boolean[] V, int[] R)\n    {        int n = M.length;\n        if (r == M.length) \n        {\n            double[][] T = new double[n][n+1];\n            for (int i = 0; i &lt; R.length; i++) \n            {\n                for (int j = 0; j &lt; n + 1; j++)\n                    T[i][j] = M[R[i]][j];\n            }\n \n            M = T;\n \n            return true;\n        }\n \n        for (int i = 0; i &lt; n; i++)\n         {\n            if (V[i]) continue;\n \n            double sum = 0;\n \n            for (int j = 0; j &lt; n; j++)\n                sum += Math.abs(M[i][j]);\n \n            if (2 * Math.abs(M[i][r]) &gt; sum) \n            { // diagonally dominant?\n                V[i] = true;\n                R[r] = i;\n \n                if (transformToDominant(r + 1, V, R))\n                    return true;\n \n                V[i] = false;\n            }\n        }\n \n        return false;\n    }\n \n    public boolean makeDominant()\n    {\n        boolean[] visited = new boolean[M.length];\n        int[] rows = new int[M.length];\n \n        Arrays.fill(visited, false);\n \n        return transformToDominant(0, visited, rows);\n    }\n \n    public void solve()\n    {\n        int iterations = 0;\n        int n = M.length;        double epsilon = 1e-15;\n        double[] X = new double[n]; // Approximations\n        double[] P = new double[n]; // Prev\n        Arrays.fill(X, 0);\n \n        while (true) \n        {\n            for (int i = 0; i &lt; n; i++) \n            {\n                double sum = M[i][n]; // b_n\n \n                for (int j = 0; j &lt; n; j++)\n                    if (j != i)\n                        sum -= M[i][j] * X[j];\n \n        // Update x_i to use in the next row calculation\n                X[i] = 1/M[i][i] * sum;\n            }\n \n            System.out.print(\"X_\" + iterations + \" = {\");\n            for (int i = 0; i &lt; n; i++)\n                System.out.print(X[i] + \" \");\n            System.out.println(\"}\");\n \n            iterations++;\n            if (iterations == 1) \n                continue;\n \n            boolean stop = true;\n            for (int i = 0; i &lt; n &amp;&amp; stop; i++)\n                if (Math.abs(X[i] - P[i]) &gt; epsilon)\n                    stop = false;\n \n            if (stop || iterations == MAX_ITERATIONS) break;\n            P = (double[])X.clone();\n        }\n    }\n \n    public static void main(String[] args) throws IOException\n    {\n        int n;\n        double[][] M;\n \nBufferedReader reader = new BufferedReader(new\n InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(System.out, true);\n \n        System.out.println(\"Enter the number of variables in the\n equation:\");\n        n = Integer.parseInt(reader.readLine());\n        M = new double[n][n+1];\n        System.out.println(\"Enter the augmented matrix:\");\n \n        for (int i = 0; i &lt; n; i++)\n         {\n            StringTokenizer strtk = new StringTokenizer(reader.readLine());\n \n            while (strtk.hasMoreTokens())\n                for (int j = 0; j &lt; n + 1 &amp;&amp; strtk.hasMoreTokens(); j++)\n                    M[i][j] = Integer.parseInt(strtk.nextToken());\n        }\n \n \n        Gauss_Seidel gausSeidel = new Gauss_Seidel(M);\n \n        if (!gausSeidel.makeDominant())\n         {\n            writer.println(\"The system isn't diagonally dominant: \" +\n                     \"The method cannot guarantee convergence.\");\n        }\n \n        writer.println();\n        gausSeidel.print();\n        gausSeidel.solve();\n    }\n}\n"}
{"ID":"10","language":"java","title":"Strassen Algorithm","content":"//Strassen Algorithm\n\nimport java.util.Scanner;\n/** Class Strassen **/\npublic class Strassen\n{\n    /** Function to multiply matrices **/\n    public int[][] multiply(int[][] A, int[][] B)\n    {        \n        int n = A.length;\n        int[][] R = new int[n][n];\n        /** base case **/\n        if (n == 1)\n            R[0][0] = A[0][0] * B[0][0];\n        else\n        {\n            int[][] A11 = new int[n/2][n/2];\n            int[][] A12 = new int[n/2][n/2];\n            int[][] A21 = new int[n/2][n/2];\n            int[][] A22 = new int[n/2][n/2];\n            int[][] B11 = new int[n/2][n/2];\n            int[][] B12 = new int[n/2][n/2];\n            int[][] B21 = new int[n/2][n/2];\n            int[][] B22 = new int[n/2][n/2];\n \n            /** Dividing matrix A into 4 halves **/\n            split(A, A11, 0 , 0);\n            split(A, A12, 0 , n/2);\n            split(A, A21, n/2, 0);\n            split(A, A22, n/2, n/2);\n            /** Dividing matrix B into 4 halves **/\n            split(B, B11, 0 , 0);\n            split(B, B12, 0 , n/2);\n            split(B, B21, n/2, 0);\n            split(B, B22, n/2, n/2);\n \n            /** \n              M1 = (A11 + A22)(B11 + B22)\n              M2 = (A21 + A22) B11\n              M3 = A11 (B12 - B22)\n              M4 = A22 (B21 - B11)\n              M5 = (A11 + A12) B22\n              M6 = (A21 - A11) (B11 + B12)\n              M7 = (A12 - A22) (B21 + B22)\n            **/\n \n            int [][] M1 = multiply(add(A11, A22), add(B11, B22));\n            int [][] M2 = multiply(add(A21, A22), B11);\n            int [][] M3 = multiply(A11, sub(B12, B22));\n            int [][] M4 = multiply(A22, sub(B21, B11));\n            int [][] M5 = multiply(add(A11, A12), B22);\n            int [][] M6 = multiply(sub(A21, A11), add(B11, B12));\n            int [][] M7 = multiply(sub(A12, A22), add(B21, B22));\n \n            /**\n              C11 = M1 + M4 - M5 + M7\n              C12 = M3 + M5\n              C21 = M2 + M4\n              C22 = M1 - M2 + M3 + M6\n            **/\n            int [][] C11 = add(sub(add(M1, M4), M5), M7);\n            int [][] C12 = add(M3, M5);\n            int [][] C21 = add(M2, M4);\n            int [][] C22 = add(sub(add(M1, M3), M2), M6);\n \n            /** join 4 halves into one result matrix **/\n            join(C11, R, 0 , 0);\n            join(C12, R, 0 , n/2);\n            join(C21, R, n/2, 0);\n            join(C22, R, n/2, n/2);\n        }\n        /** return result **/ \n           return R;\n    }\n    /** Funtion to sub two matrices **/\n    public int[][] sub(int[][] A, int[][] B)\n    {\n        int n = A.length;\n        int[][] C = new int[n][n];\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                C[i][j] = A[i][j] - B[i][j];\n        return C;\n    }\n    /** Funtion to add two matrices **/\n    public int[][] add(int[][] A, int[][] B)\n    {\n        int n = A.length;\n        int[][] C = new int[n][n];\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                C[i][j] = A[i][j] + B[i][j];\n        return C;\n    }\n    /** Funtion to split parent matrix into child matrices **/\n    public void split(int[][] P, int[][] C, int iB, int jB) \n    {\n        for(int i1 = 0, i2 = iB; i1 &lt; C.length; i1++, i2++)\n            for(int j1 = 0, j2 = jB; j1 &lt; C.length; j1++, j2++)\n                C[i1][j1] = P[i2][j2];\n    }\n    /** Funtion to join child matrices intp parent matrix **/\n    public void join(int[][] C, int[][] P, int iB, int jB) \n    {\n        for(int i1 = 0, i2 = iB; i1 &lt; C.length; i1++, i2++)\n            for(int j1 = 0, j2 = jB; j1 &lt; C.length; j1++, j2++)\n                P[i2][j2] = C[i1][j1];\n    }    \n    /** Main function **/\n    public static void main (String[] args)\n     {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Strassen Multiplication Algorithm Test\n\");\n        /** Make an object of Strassen class **/\n        Strassen s = new Strassen();\n \n        System.out.println(\"Enter order n :\");\n        int N = scan.nextInt();\n        /** Accept two 2d matrices **/\n        System.out.println(\"Enter N order matrix 1\n\");\n        int[][] A = new int[N][N];\n        for (int i = 0; i &lt; N; i++)\n            for (int j = 0; j &lt; N; j++)\n                A[i][j] = scan.nextInt();\n \n        System.out.println(\"Enter N order matrix 2\n\");\n        int[][] B = new int[N][N];\n        for (int i = 0; i &lt; N; i++)\n            for (int j = 0; j &lt; N; j++)\n                B[i][j] = scan.nextInt();\n \n        int[][] C = s.multiply(A, B);\n \n        System.out.println(\"\nProduct of matrices A and  B : \");\n        for (int i = 0; i &lt; N; i++)\n        {\n            for (int j = 0; j &lt; N; j++)\n                System.out.print(C[i][j] +\" \");\n            System.out.println();\n        }\n \n    }\n}\n"}
{"ID":"11","language":"java","title":"Matrix Multiplication","content":"//Matrix Multiplication\n\npackage com.sanfoundry.numerical;\nimport java.util.Scanner;\n \npublic class MatixMultiplication\n{\n    public static void main(String args[])\n    {\n        int n;\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter the base of squared matrices\");\n        n = input.nextInt();\n        int[][] a = new int[n][n];\n        int[][] b = new int[n][n];\n        int[][] c = new int[n][n];\n        System.out.println(\"Enter the elements of 1st martix row wise \n\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                a[i][j] = input.nextInt();\n            }\n        }\n  System.out.println(\"Enter the elements of 2nd martix row wise \n\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                b[i][j] = input.nextInt();\n            }\n        }\n        System.out.println(\"Multiplying the matrices...\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                for (int k = 0; k &lt; n; k++)\n                {\n                    c[i][j] = c[i][j] + a[i][k] * b[k][j];\n                }\n            }\n        }\n        System.out.println(\"The product is:\");\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                System.out.print(c[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        input.close();\n    }\n}"}
{"ID":"12","language":"java","title":"Find Path Between Two Nodes in a Graph","content":"//Find Path Between Two Nodes in a Graph\n\nimport java.util.*;\nclass Node \n{\n    public int label; // this node's label (parent node in path tree)\n    public int weight; // weight of edge to this node (distance to start)\n \n    public Node(int v, int w) \n    { \n        label = v;\n        weight = w;\n    }\n}\n \npublic class ShortestPath \n{\n    public static Scanner in; // for standard input\n    public static int n, m; // n = #vertices, m = #edges\n    public static LinkedList[] graph; // adjacency list representation\n    public static int start, end; // start and end points for shortest path\n \n    public static void main(String[] args) \n    {\n        in = new Scanner(System.in);\n \n        // Input the graph:\n        System.out\n                .println(\"Enter the number of components and wires in a$ circuit:\");\n        n = in.nextInt();\n        m = in.nextInt();\n \n        // Initialize adjacency list structure to empty lists:\n        graph = new LinkedList[n];\n        for (int i = 0; i &lt; n; i++)\n            graph[i] = new LinkedList();\n \n        // Add each edge twice, once for each endpoint:\nSystem.out.println(\"Mention the wire between components and its length:\");\n        for (int i = 0; i &lt; m; i++)\n         {\n            int v1 = in.nextInt();\n            int v2 = in.nextInt();\n            int w = in.nextInt();\n            graph[v1].add(new Node(v2, w));\n            graph[v2].add(new Node(v1, w));\n        }\n \n        // Input starting and ending vertices:\nSystem.out.println(\"Enter the start and end for which length is to be\nminimized: \");\n        start = in.nextInt();\n        end = in.nextInt();\n \n        // FOR DEBUGGING ONLY:\n        displayGraph();\n \n        // Print shortest path from start to end:\n        shortest();\n    }\n \n    public static void shortest() \n    {\n        boolean[] done = new boolean[n];\n        Node[] table = new Node[n];\n        for (int i = 0; i &lt; n; i++)\n            table[i] = new Node(-1, Integer.MAX_VALUE); \n \n        table[start].weight = 0;\n  \n        for (int count = 0; count &lt; n; count++)\n         {\n            int min = Integer.MAX_VALUE;\n            int minNode = -1;\n            for (int i = 0; i &lt; n; i++)\n                if (!done[i] &amp;&amp; table[i].weight &lt; min) \n                {\n                    min = table[i].weight;\n                    minNode = i;\n                }\n \n            done[minNode] = true;\n \n            ListIterator iter = graph[minNode].listIterator();\n            while (iter.hasNext()) \n            {\n                Node nd = (Node) iter.next();\n                int v = nd.label;\n                int w = nd.weight;\n \n                if (!done[v] &amp;&amp; table[minNode].weight + w &lt; table[v].weight)\n                {\n                    table[v].weight = table[minNode].weight + w;\n                    table[v].label = minNode;\n                }\n            }\n        }\n        for (int i = 0; i &lt; n; i++) \n        {\n            if (table[i].weight &lt; Integer.MAX_VALUE)\n             {\n                System.out.print(\"Wire from \" + i + \" to \" + start\n                        + \" with length \" + table[i].weight + \": \");\n                int next = table[i].label;\n                while (next &gt;= 0) \n                {\n                    System.out.print(next + " ");\n                    next = table[next].label;\n                }\n                System.out.println();\n            } else\n                System.out.println(\"No wire from \" + i + \" to \" + start);\n        }\n    }\n \n    public static void displayGraph()\n     {\n        for (int i = 0; i &lt; n; i++) \n        {\n            System.out.print(i + \": \");\n            ListIterator nbrs = graph[i].listIterator(0);\n            while (nbrs.hasNext()) \n            {\n                Node nd = (Node) nbrs.next();\n                System.out.print(nd.label + \"(\" + nd.weight + \") \");\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"ID":"13","language":"java","title":"Generate Randomized Sequence of Given Range of Numbers","content":"//Generate Randomized Sequence of Given Range of Numbers\n\nimport java.util.Random;\nimport java.util.Scanner;\n \npublic class Randomized_Sequence_Random_Numbers\n{\n    public static void main(String args[])\n    {\n        Random rand = new Random();\n        Scanner sc = new Scanner(System.in);\n   System.out.println(\"Enter the starting and ending of the sequence: \");\n        int start = sc.nextInt();\n        int end = sc.nextInt();\n \n        for(int i=0; i&lt;15; i++)\n        {\n            System.out.print(rand.nextInt(end-start+1)+start + ", ");\n        }\n        System.out.print(\"...\");\n        sc.close();\n    }\n}"}
{"ID":"14","language":"java","title":"Generate Random Hexadecimal Byte","content":"//Generate Random Hexadecimal Byte\n\nimport java.util.Random;\npublic class Generate_Random_Hex_Bytes \n{\n    public static void main(String args[])\n    {\n        Random random = new Random();\n        int val = random.nextInt();\n        String Hex = new String();\n        Hex = Integer.toHexString(val);\n        System.out.println(\"Random Hex Byte: \" + Hex);\n    }\n}\n"}
{"ID":"15","language":"java","title":"Use rand and srand Functions","content":"//Use rand and srand Functions\n\nimport java.util.Random;\nimport java.util.UUID;\n \npublic class Rand_and_Srand \n{\n    public static void main(String args[])\n    {\n        System.out.println(\"The numbers using rand\");\n        for(int i=0; i&lt;5; i++)\n        {\n            Random rand = new Random();\n            System.out.println(Math.abs(rand.nextInt()));\n        }\n \n        System.out.println(\"The numbers using srand\");\n        for(int i=0; i&lt;5; i++)\n        {\n\n         System.out.println(Math.abs(UUID.randomUUID().getMostSignificantBits(\n)));\n        }\n    }\n}\n"}
{"ID":"16","language":"java","title":"Borwein Algorithm","content":"//Borwein Algorithm\n\nimport java.util.Scanner;\n/** Class Borwein **/\npublic class Borwein\n{\n    /** compute 1/pi **/\n    public double getOneByPi(int k)\n    {\n        double ak = 6.0 - 4 * Math.sqrt(2);\n        double yk = Math.sqrt(2) - 1.0;\n \n        double ak1 ;\n        double yk1 ;\n        for (int i = 0; i &lt; k; i++)\n        {\n            yk1 = (1 - Math.pow((1 - yk * yk * yk * yk),(0.25)))/(1 +\n Math.pow((1 - yk * yk * yk * yk),(0.25)));\n        ak1 = ak * Math.pow((1 + yk1), 4) - Math.pow(2, 2 * i + 3) *\n yk1 * (1 + yk1 + yk1 * yk1);\n            yk = yk1;\n            ak = ak1;\n        }\n        return ak;\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Borwein 1/Pi Algorithm Test\n\");\n        /** Make an object of Borwein class **/\n        Borwein b = new Borwein();\n \n        System.out.println(\"Enter number of iterations \");\n        int k = scan.nextInt();\n \n        System.out.println(\"\nValue of 1/pi : \"+ b.getOneByPi(k));\n    }\n}\n"}
{"ID":"17","language":"java","title":"Shunting Yard Algorithm","content":"//Shunting Yard Algorithm\n\nimport java.util.Scanner;\n \n/** Class ShuntingYard **/\npublic class ShuntingYard\n{\n    /** enum **/\n    private enum Precedence\n    {\n        lparen(0), rparen(1), plus(2), minus(3), divide(4), times(5),\n mod(6), eos(7), operand(8);\n \n        private int index;\n        Precedence(int index)\n        {\n            this.index = index;\n        }\n        public int getIndex()\n        {\n            return index;\n        }        \n    } \n    /** in stack precedence **/\n    private static final int[] isp = {0, 19, 12, 12, 13, 13, 13, 0};\n    /** incoming character precedence **/\n    private static final int[] icp = {20, 19, 12, 12, 13, 13, 13, 0};\n    /** operators **/\n  private static final char[] operators = {'{', '}', '+', '-', '/', '*', '%', ' '};\n    /** precedence stack **/\n    private Precedence[] stack; \n    /** stack top pointer **/\n    private int top;\n \n    /** pop element from stack **/\n    private Precedence pop()\n    {\n        return stack[top--];\n    }\n    /** push element onto stack **/\n    private void push(Precedence ele)\n    {\n        stack[++top] = ele;\n    }\n    /** get precedence token for symbol **/\n    public Precedence getToken(char symbol)\n    {\n        switch (symbol)\n        {\n        case '('  : return Precedence.lparen;\n        case ')'  : return Precedence.rparen;\n        case '+'  : return Precedence.plus;\n        case '-'  : return Precedence.minus;\n        case '/'  : return Precedence.divide;\n        case '*'  : return Precedence.times;\n        case '%'  : return Precedence.mod;\n        case ' '  : return Precedence.eos;\n        default   : return Precedence.operand;\n        }\n    }\n \n    /** Function to convert infix to postfix **/\n    public String postfix(String infix)\n    {\n        String postfix = "";\n        top = 0;\n        stack = new Precedence[infix.length()];\n        stack[0] = Precedence.eos;\n        Precedence token;\n        for (int i = 0; i &lt; infix.length(); i++)\n        {\n            token = getToken(infix.charAt(i));\n            /** if token is operand append to postfix **/\n            if (token == Precedence.operand)\n                postfix = postfix + infix.charAt(i);\n            /** if token is right parenthesis pop till matching left$ parenthesis **/\n            else if (token == Precedence.rparen)\n            {\n                while (stack[top] != Precedence.lparen)\n                    postfix = postfix + operators[pop().getIndex()];\n                /** discard left parenthesis **/\n                pop();\n            }\n            /** else pop stack elements whose precedence is greater than$ that of token **/\n            else\n            {\n      while (isp[stack[top].getIndex()] &gt;= icp[token.getIndex()])\n                    postfix = postfix + operators[pop().getIndex()];\n                push(token);\n            }\n        }\n        /** pop any remaining elements in stack **/\n        while ((token = pop()) != Precedence.eos)\n            postfix = postfix + operators[token.getIndex()];\n \n        return postfix;\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Shunting Yard Algorithm Test\n\");\n        /** Make an object of ShuntingYard class **/\n        ShuntingYard sy = new ShuntingYard();\n \n        /** Accept infix expression **/\n        System.out.println(\"Enter infix expression\");\n        String infix = scan.next();\n \n        String postfix = sy.postfix(infix);\n        System.out.println(\"\nPostfix expression : \"+ postfix);\n    }\n}\n"}
{"ID":"18","language":"java","title":"Repeated Squaring Algorithm","content":"//Repeated Squaring Algorithm\n\nimport java.util.Scanner;\n \n/** Class RepeatedSquaring **/\npublic class RepeatedSquaring\n{\n    /** Function for repeated squaring **/\n    public double expBySquaring(double x, int n)\n    {\n        if (n &lt; 0)\n            return expBySquaring(1 / x, -n);\n        else if (n == 0)\n            return 1;\n        else if (n == 1)\n            return x;\n        else if (n % 2 == 0)\n            return expBySquaring(x * x, n / 2);\n        else \n            return x * expBySquaring(x * x, (n - 1)/2);   \n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Repeated Squaring Algorithm Test\n\");\n        /** Make an object of RepeatedSquaring class **/\n        RepeatedSquaring rs = new RepeatedSquaring();\n \n        /** Accept n , k **/\n        System.out.println(\"\nEnter n and k of (N ^ K)\");\n        double n = scan.nextDouble();\n        int k = scan.nextInt();\n        double result = rs.expBySquaring(n, k);\n \n        System.out.println(\"\nResult : \"+ result); \n           }\n}\n"}
{"ID":"19","language":"java","title":"Gaussian Elimination Algorithm","content":"//Gaussian Elimination Algorithm\n\nimport java.util.Scanner;\n/** Class GaussianElimination **/\npublic class GaussianElimination\n{\n    public void solve(double[][] A, double[] B)\n    {\n        int N = B.length;\n        for (int k = 0; k &lt; N; k++) \n        {\n            /** find pivot row **/\n            int max = k;\n            for (int i = k + 1; i &lt; N; i++) \n                if (Math.abs(A[i][k]) &gt; Math.abs(A[max][k])) \n                    max = i;\n \n            /** swap row in A matrix **/ \n               double[] temp = A[k]; \n            A[k] = A[max]; \n            A[max] = temp;\n \n            /** swap corresponding values in constants matrix **/\n            double t = B[k]; \n            B[k] = B[max]; \n            B[max] = t;\n \n            /** pivot within A and B **/\n            for (int i = k + 1; i &lt; N; i++) \n            {\n                double factor = A[i][k] / A[k][k];\n                B[i] -= factor * B[k];\n                for (int j = k; j &lt; N; j++) \n                    A[i][j] -= factor * A[k][j];\n            }\n        }\n $\n        /** Print row echelon form **/\n        printRowEchelonForm(A, B);\n \n        /** back substitution **/\n        double[] solution = new double[N];\n        for (int i = N - 1; i &gt;= 0; i--) \n        {\n            double sum = 0.0;\n            for (int j = i + 1; j &lt; N; j++) \n                sum += A[i][j] * solution[j];\n            solution[i] = (B[i] - sum) / A[i][i];\n        }        \n        /** Print solution **/\n        printSolution(solution);\n    }\n    /** function to print in row    echleon form **/\n    public void printRowEchelonForm(double[][] A, double[] B)\n    {\n        int N = B.length;\n        System.out.println(\"\nRow Echelon form : \");\n        for (int i = 0; i &lt; N; i++)\n           {\n               for (int j = 0; j &lt; N; j++)\n                   System.out.printf(\"%.3f \", A[i][j]);\n               System.out.printf(\"| %.3f\n\", B[i]);\n           }\n           System.out.println();\n    }\n    /** function to print solution **/\n    public void printSolution(double[] sol)\n    {\n        int N = sol.length;\n        System.out.println(\"\nSolution : \");\n        for (int i = 0; i &lt; N; i++) \n            System.out.printf(\"%.3f \", sol[i]);  \n         System.out.println();     \n    }    \n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Gaussian Elimination Algorithm Test\n\");\n        /** Make an object of GaussianElimination class **/\n        GaussianElimination ge = new GaussianElimination();\n \n        System.out.println(\"\nEnter number of variables\");\n        int N = scan.nextInt();\n \n        double[] B = new double[N];\n        double[][] A = new double[N][N];\n \n        System.out.println(\"\nEnter \"+ N +\" equations coefficients \");\n        for (int i = 0; i &lt; N; i++)\n            for (int j = 0; j &lt; N; j++)\n                A[i][j] = scan.nextDouble();\n \n        System.out.println(\"\nEnter \"+ N +\" solutions\");\n        for (int i = 0; i &lt; N; i++)\n            B[i] = scan.nextDouble();\n \n        ge.solve(A,B);\n    }\n}\n"}
{"ID":"20","language":"java","title":"Sieve Of Atkin","content":"//Sieve Of Atkin\n\nimport java.util.Scanner;\n/** Class SieveOfAtkin **/\npublic class  SieveOfAtkin\n{\n    /** Function to calculate all primes less than n **/\n    private boolean[] calcPrimes(int limit)\n    {\n        /** initialize the sieve **/\n        boolean[] prime = new boolean[limit + 1];\n        prime[2] = true;\n        prime[3] = true;\n        int root = (int) Math.ceil(Math.sqrt(limit));\n \n        /** put in candidate primes: \n           integers which have an odd number of\n           representations by certain quadratic forms **/\n        for (int x = 1; x &lt; root; x++)\n        {\n            for (int y = 1; y &lt; root; y++)\n            {\n                int n = 4 * x * x + y * y;\n                if (n &lt;= limit &amp;&amp; (n % 12 == 1 || n % 12 == 5))\n                    prime[n] = !prime[n];\n                n = 3 * x * x + y * y;\n                if (n &lt;= limit &amp;&amp; n % 12 == 7)\n                    prime[n] = !prime[n];\n                n = 3 * x * x - y * y;\n                if ((x &gt; y) &amp;&amp; (n &lt;= limit) &amp;&amp; (n % 12 == 11))\n                    prime[n] = !prime[n];\n            }\n        }\n  /** eliminate composites by sieving, omit multiples of its square **/\n        for (int i = 5; i &lt;= root; i++)\n            if (prime[i])\n                for (int j = i * i; j &lt; limit; j += i * i)\n                    prime[j] = false;\n \n        return prime;\n    }\n    /** Function to get all primes **/\n    public void getPrimes(int N)\n    {\n        boolean[] primes = calcPrimes(N);\n        display(primes);\n    }\n    /** Function to display all primes **/\n    public void display(boolean[] primes)\n    {\n        System.out.print(\"\nPrimes = \");\n        for (int i = 2; i &lt; primes.length; i++)\n            if (primes[i])\n                System.out.print(i +" ");\n        System.out.println();\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Sieve Of Atkin Prime Algorithm Test\n\");\n        /** Make an object of SieveOfAtkin class **/\n         SieveOfAtkin soa = new  SieveOfAtkin();\n        /** Accept n **/\n   System.out.println(\"Enter number to find all primes less than the$ number\n\");\n        int n = scan.nextInt();\n        soa.getPrimes(n);     \n       }\n}\n"}
{"ID":"21","language":"java","title":"Sieve Of Eratosthenes","content":"//Sieve Of Eratosthenes\n\nimport java.util.Scanner;\n/** Class SieveOfEratosthenes **/\npublic class SieveOfEratosthenes\n{\n    /** Function to calculate all primes less than n **/\n    private int[] calcPrimes(int N)\n    {\n        int[] arr = new int[N + 1];\n        for (int i = 2; i &lt;= Math.sqrt(N); i++)\n        {\n            if (arr[i] == 0)\n            {\n                for (int j = i * i; j &lt;= N; j += i)\n                {\n                    arr[j] = 1;\n                }\n            }\n        }\n        return arr;\n    }\n    /** Function to get all primes **/\n    public void getPrimes(int N)\n    {\n        int[] primes = calcPrimes(N);\n        display(primes);\n    }\n    /** Function to display all primes **/\n    public void display(int[] primes)\n    {\n        System.out.print(\"\nPrimes = \");\n        for (int i = 2; i &lt; primes.length; i++)\n            if (primes[i] == 0)\n                System.out.print(i +" ");\n        System.out.println();\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Sieve Of Eratosthenes Prime Algorithm\nTest\n\");\n        /** Make an object of SieveOfEratosthenes class **/\n        SieveOfEratosthenes soe = new SieveOfEratosthenes();\n        /** Accept n **/\n  System.out.println(\"Enter number to find all primes less than the$ number\n\");\n        int n = scan.nextInt();\n        soe.getPrimes(n);     \n       }\n}\n"}
{"ID":"22","language":"java","title":"Addition Operation Using Bitwise Operators","content":"//Addition Operation Using Bitwise Operators\n\nimport java.util.Scanner;\npublic class Bitwise_Addition \n{\n    static int add(int x, int y)\n    {\n        int carry;\n        while(y!=0)\n        {\n            carry = x &amp; y;\n            x = x ^ y;\n            y = carry &lt;&lt; 1;\n        }\n        return x;\n    }\n    public static void main(String args[])\n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter the numbers to be added:\");\n        int x = input.nextInt();\n        int y = input.nextInt();\n        System.out.println(\"The Summation is: \"+add(x, y));\n        input.close();\n    }\n}\n"}
{"ID":"23","language":"java","title":"Solve the 0-1 Knapsack Problem","content":"//Solve the 0-1 Knapsack Problem\n\nimport java.util.Scanner;\npublic class Zero_One_Knapsack\n{\n    public void solve(int[] wt, int[] val, int W, int N)\n    {\n        int NEGATIVE_INFINITY = Integer.MIN_VALUE;\n        int[][] m = new int[N + 1][W + 1];\n        int[][] sol = new int[N + 1][W + 1];\n        for (int i = 1; i &lt;= N; i++)\n        {\n            for (int j = 0; j &lt;= W; j++)\n            {\n                int m1 = m[i - 1][j];\n                int m2 = NEGATIVE_INFINITY; \n                if (j &gt;= wt[i])\n                    m2 = m[i - 1][j - wt[i]] + val[i];\n                m[i][j] = Math.max(m1, m2);\n                sol[i][j] = m2 &gt; m1 ? 1 : 0;\n            }\n        }        \n        int[] selected = new int[N + 1];\n        for (int n = N, w = W; n &gt; 0; n--)\n        {\n            if (sol[n][w] != 0)\n            {\n                selected[n] = 1;\n                w = w - wt[n];\n            }\n            else\n                selected[n] = 0;\n        }\n        System.out.print(\"\nItems with weight \");\n        for (int i = 1; i &lt; N + 1; i++)\n            if (selected[i] == 1)\n                System.out.print(val[i] +" ");\n        System.out.println(\"are selected by knapsack algorithm.\");\n    }\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        Zero_One_Knapsack ks = new Zero_One_Knapsack();\n \n        System.out.println(\"Enter number of elements \");\n        int n = scan.nextInt();\n \n        int[] wt = new int[n + 1];\n        int[] val = new int[n + 1];\n \n        System.out.println(\"Enter weight for \"+ n +\" elements\");\n        for (int i = 1; i &lt;= n; i++)\n            wt[i] = scan.nextInt();\n        System.out.println(\"Enter value for \"+ n +\" elements\");\n        for (int i = 1; i &lt;= n; i++)\n            val[i] = scan.nextInt();\n \n        System.out.println(\"Enter knapsack weight \");\n        int W = scan.nextInt();\n \n        ks.solve(wt, val, W, n);\n        scan.close();\n    }\n}\n"}
{"ID":"24","language":"java","title":"Knapsack Algorithm","content":"//Knapsack Algorithm\n\nimport java.util.Scanner;\n/** Class Knapsack **/\npublic class Knapsack\n{\n    public void solve(int[] wt, int[] val, int W, int N)\n    {\n        int NEGATIVE_INFINITY = Integer.MIN_VALUE;\n        int[][] m = new int[N + 1][W + 1];\n        int[][] sol = new int[N + 1][W + 1];\n \n        for (int i = 1; i &lt;= N; i++)\n        {\n            for (int j = 0; j &lt;= W; j++)\n            {\n                int m1 = m[i - 1][j];\n                int m2 = NEGATIVE_INFINITY; \n                if (j &gt;= wt[i])\n                    m2 = m[i - 1][j - wt[i]] + val[i];\n                /** select max of m1, m2 **/\n                m[i][j] = Math.max(m1, m2);\n                sol[i][j] = m2 &gt; m1 ? 1 : 0;\n            }\n        }        \n        /** make list of what all items to finally select **/\n        int[] selected = new int[N + 1];\n        for (int n = N, w = W; n &gt; 0; n--)\n        {\n            if (sol[n][w] != 0)\n            {\n                selected[n] = 1;                w = w - wt[n];\n            }\n            else\n                selected[n] = 0;\n        }\n        /** Print finally selected items **/\n        System.out.println(\"nItems selected : \");\n        for (int i = 1; i &lt; N + 1; i++)\n            if (selected[i] == 1)\n                System.out.print(i +" ");\n        System.out.println();\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Knapsack Algorithm Test\n\");\n        /** Make an object of Knapsack class **/\n        Knapsack ks = new Knapsack();\n \n        System.out.println(\"Enter number of elements \");\n        int n = scan.nextInt();\n \n        int[] wt = new int[n + 1];\n        int[] val = new int[n + 1];\n \n        System.out.println(\"\nEnter weight for \"+ n +\" elements\");\n        for (int i = 1; i &lt;= n; i++)\n            wt[i] = scan.nextInt();\n        System.out.println(\"\nEnter value for \"+ n +\" elements\");\n        for (int i = 1; i &lt;= n; i++)\n            val[i] = scan.nextInt();\n \n        System.out.println(\"\nEnter knapsack weight \");\n        int W = scan.nextInt();\n \n        ks.solve(wt, val, W, n);\n    }\n}\n"}
{"ID":"25","language":"java","title":"2D FFT Inplace Given a Complex 2D Array","content":"//2D FFT Inplace Given a Complex 2D Array\n\nimport java.util.Scanner;\npublic class TwoD_FFT \n{\n    static void twoDfft(double[][] inputData, double[][] realOut,\n            double[][] imagOut, double[][] amplitudeOut) \n    {\n        int height = inputData.length;\n        int width = inputData[0].length;\n \n        // Two outer loops iterate on output data.\n        for (int yWave = 0; yWave &lt; height; yWave++) \n        {\n            for (int xWave = 0; xWave &lt; width; xWave++) \n            {\n                // Two inner loops iterate on input data.\n                for (int ySpace = 0; ySpace &lt; height; ySpace++) \n                {\n                    for (int xSpace = 0; xSpace &lt; width; xSpace++) \n                    {\n                        // Compute real, imag, and ampltude.\n                realOut[yWave][xWave] += (inputData[ySpace]\n[xSpace] * Math\n                                .cos(2\n                                        * Math.PI\n            * ((1.0 * xWave * xSpace / width) + (1.0\n                            * yWave * ySpace / height))))\n                                / Math.sqrt(width * height);\n                imagOut[yWave][xWave] -= (inputData[ySpace]\n[xSpace] * Math\n                                .sin(2\n                                        * Math.PI\n                    * ((1.0 * xWave * xSpace / width) + (1.0\n                                                * yWave * ySpace / height))))\n                                / Math.sqrt(width * height);\n                        amplitudeOut[yWave][xWave] = Math\n                                .sqrt(realOut[yWave][xWave]\n                                        * realOut[yWave][xWave]\n                                        + imagOut[yWave][xWave]\n                                        * imagOut[yWave][xWave]);\n                    }\n                    System.out.println(realOut[yWave][xWave] + \" + \"\n                            + imagOut[yWave][xWave] + \" i\");\n                }\n            }\n        }\n    }\n \n    public static void main(String args[]) \n    {\n        System.out.println(\"Enter the size: \");\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        double[][] input = new double[n][n];\n        double[][] real = new double[n][n];\n        double[][] img = new double[n][n];\n        double[][] amplitutude = new double[n][n];\n        System.out.println(\"Enter the 2D elements \");\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                input[i][j] = sc.nextDouble();\n \n        twoDfft(input, real, img, amplitutude);\n \n        sc.close();\n    }\n}\n"}
{"ID":"26","language":"java","title":"Cubic convergence 1/pi Algorithm","content":"//Cubic convergence 1/pi Algorithm\n\nimport java.util.Scanner;\n/** Class CubicConvergencePi **/\npublic class CubicConvergencePi\n{\n    /** compute 1/pi **/\n    public double getOneByPi(int k)\n    {\n        double ak = 1.0/3.0;\n        double sk = (Math.sqrt(3) - 1)/2;\n        double ak1, sk1, rk1;\n        for (int i = 0; i &lt; k; i++)\n        {\n            rk1 = 3.0 / (1 + 2 * Math.pow((1 - sk * sk * sk), (1.0/3.0)));\n            sk1 = (rk1 - 1)/2.0;\n            ak1 = rk1 * rk1 * ak - Math.pow(3, i) * (rk1 * rk1 - 1);\n            ak = ak1;\n            sk = sk1;\n        }\n        return ak;    \n        }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n    System.out.println(\"Cubic Convergence 1/Pi Algorithm Test\n\");\n        /** Make an object of CubicConvergence class **/\n        CubicConvergencePi  cc = new CubicConvergencePi ();\n \n        System.out.println(\"Enter number of iterations\");\n        int k = scan.nextInt();\n \n        System.out.println(\"\nValue of 1/pi : \"+ cc.getOneByPi(k));\n    }\n}\n"}
{"ID":"27","language":"java","title":"Borwein Algorithm","content":"//Borwein Algorithm\n\nimport java.util.Scanner;\n/** Class Borwein **/\npublic class Borwein\n{\n    /** compute 1/pi **/\n    public double getOneByPi(int k)\n    {\n        double ak = 6.0 - 4 * Math.sqrt(2);\n        double yk = Math.sqrt(2) - 1.0;\n \n        double ak1 ;\n        double yk1 ;\n        for (int i = 0; i &lt; k; i++)\n        {\nyk1 = (1 - Math.pow((1 - yk * yk * yk * yk),(0.25)))/(1 +$ Math.pow((1 - yk * yk * yk * yk),(0.25)));\nak1 = ak * Math.pow((1 + yk1), 4) - Math.pow(2, 2 * i + 3) \n* yk1 * (1 + yk1 + yk1 * yk1);\n            yk = yk1;\n            ak = ak1;\n        }\n        return ak;\n    }\n    /** Main function **/\n    public static void main (String[] args) \n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Borwein 1/Pi Algorithm Test\n\");\n        /** Make an object of Borwein class **/\n        Borwein b = new Borwein();\n \n        System.out.println(\"Enter number of iterations \");\n        int k = scan.nextInt();\n \n        System.out.println(\"\nValue of 1/pi : \"+ b.getOneByPi(k));\n    }\n}\n"}
{"ID":"28","language":"java","title":"AudioClip: stop","content":"//AudioClip: stop()\n\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.net.URL;\n\npublic class MainClass {\n  public static void main(String[] args) {\n    try {\n      URL url = new URL(\"file:youraudiofile.wav\" );\n      AudioClip ac = Applet.newAudioClip(url);\n      ac.play();\n\n      System.out.println(\"Press any key to exit.\");\n      System.in.read();\n      ac.stop();\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n"}
{"ID":"29","language":"java","title":"AudioClip: play()","content":"//AudioClip: play()\n\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.net.URL;\n\npublic class MainClass {\n  public static void main(String[] args) {\n    try {\n      URL url = new URL(\"file:youraudiofile.wav\" );\n      AudioClip ac = Applet.newAudioClip(url);\n      ac.play();\n\n      System.out.println(\"Press any key to exit.\");\n      System.in.read();\n      ac.stop();\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}"}
{"ID":"30","language":"java","title":"Nth Root Algorithm","content":"//Nth Root Algorithm\n\nimport java.util.Scanner;\n/** Class NthRoot **/\npublic class NthRoot\n{\n    public double nthroot(int n, double x) \n    {\n        return nthroot(n, x, .0001);\n    }\n    public double nthroot(int n, double x, double p) \n    {\n        if(x &lt; 0) \n        {\n            System.err.println(\"Negative!\");\n            return -1;\n        }\n        if(x == 0) \n            return 0;\n        double x1 = x;\n        double x2 = x / n; \n         while (Math.abs(x1 - x2) &gt; p) \n        {\n            x1 = x2;\n            x2 = ((n - 1.0) * x2 + x / Math.pow(x2, n - 1.0)) / n;\n        }\n        return x2;\n    }\n    /** Main **/\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Nth Root Algorithm Test\n\");\n        System.out.println(\"Enter n and x\");\n        int n = scan.nextInt();\n        double x = scan.nextInt();\n        NthRoot nr = new NthRoot();\n        double root = nr.nthroot(n, x);\n        System.out.println(\"\nRoot = \"+ root);\n    }    \n}\n\nAudioClip: play()\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.net.URL;\n\npublic class MainClass {\n  public static void main(String[] args) {\n    try {\n      URL url = new URL(\"file:youraudiofile.wav\" );\n      AudioClip ac = Applet.newAudioClip(url);\n      ac.play();\n\n      System.out.println(\"Press any key to exit.\");\n      System.in.read();\n      ac.stop();\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n\nAudioClip: stop()\nimport java.applet.Applet;\nimport java.applet.AudioClip;\nimport java.net.URL;\n\npublic class MainClass {\n  public static void main(String[] args) {\n    try {\n      URL url = new URL(\"file:youraudiofile.wav\" );\n      AudioClip ac = Applet.newAudioClip(url);\n      ac.play();\n\n      System.out.println(\"Press any key to exit.\");\n      System.in.read();\n      ac.stop();\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n  }\n}\n"}
{"ID":"31","language":"java","title":"Horner Algorithm","content":"//Horner Algorithm import java.util.Scanner;\n\n    public class Horner\n\n    {\n    private int sum;\n     /** constructor **/\n    public Horner(int[] cof, int x)\n    {\n        sum = 0;\n        calcSum(cof, x, cof.length - 1);\n        display();\n    }\n       /** Calculate sum *\n*/\n    private void calcSum(int[] cof, int x, int N)\n    {\n        sum = cof[N] * x;\n        for (int i = N - 1; i &gt;= 1; i--)\n        sum = (sum + cof[i]) * x;\n        sum += cof[0];\n    }\n    public void display()\n    {\n        System.out.println(\"Evaluated sum = \"+ sum);\n    }\n      /** main method **/\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Horner Algorithm Test\n\");\n        System.out.println(\"Enter highest power\");\n           int n = scan.nextInt();\n           int[] arr = new int[n + 1];\n      System.out.println(\"\nEnter \"+ (n + 1) +\" coefficients in$ increasing order\");\n       for (int i = 0; i &lt;= n; i++)\n           arr[i] = scan.nextInt();\n      System.out.println(\"\nEnter x\");\n      int x = scan.nextInt();\n          Horner h = new Horner(arr, x);\n       }\n     }\n"}